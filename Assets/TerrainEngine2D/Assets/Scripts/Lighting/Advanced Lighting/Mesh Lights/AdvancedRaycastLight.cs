using System.Collections.Generic;
using UnityEngine;

// Copyright (C) 2018 Matthew K Wilson

namespace TerrainEngine2D.Lighting {
    /// <summary>
    /// A light generated by raycasting to collider edges
    /// </summary>
    public class AdvancedRaycastLight : RaycastLight
    {
        /// <summary>
        /// Offset of raycasts from the terrain edge point
        /// </summary>
        [Tooltip("Offset of raycasts from terrain edge point")]
        public float RaycastOffset = 0.001f;
        /// <summary>
        /// The threshold of whether the correct raycast point was hit
        /// </summary>
        [Tooltip("Threshold of whether the correct point was hit")]
        public float RaycastHitThreshold = 0.5f;

        /// <summary>
        /// Calculate the light mesh points
        /// </summary>
        protected override void CalculateLighting()
        {
            List<Vector2> raycastPoints = new List<Vector2>();
            Vector2 position = transform.position;

            //-----Find all the directions to shoot rays-----

            List<float> angles = new List<float>();
            //Direction the light is facing
            float globalRotation = transform.eulerAngles.z;
            //The angles of the two furthest rays from the center (one clockwise other counterclockwise from the Global Rotation)
            float angleA = (360 - globalRotation) - LightAngle / 2f;
            float angleB = (360 - globalRotation) + LightAngle / 2f;
            if (angleA < 0)
                angleA += 360;
            if (angleB >= 360)
                angleB -= 360;

            //Find all the encapsulated terrain chunks
            Collider2D[] colliders = Physics2D.OverlapCircleAll(position, LightRadius, ObstacleMask);
            foreach(Collider2D collider in colliders)
            {
                PolygonCollider2D currCollider = collider.GetComponent<PolygonCollider2D>();
                if (currCollider == null)
                    continue;

                Vector2 chunkPos = collider.transform.position;
                //Loop through all the points in each path of the terrain chunk collider
                for (int j = 0; j < currCollider.pathCount; j++)
                {
                    Vector2[] path = currCollider.GetPath(j);
                    for (int k = 0; k < path.Length; k++)
                    {
                        Vector2 point = path[k] + chunkPos;
                        float distance = Vector2.Distance(position, point);
                        Vector2 localPoint = point - position;
                        //Find the angle of the collider point from angleA
                        float angle = Mathf.Atan2(localPoint.x, localPoint.y) * Mathf.Rad2Deg;
                        if (angle < 0)
                            angle += 360;
                        //Angle of the light transform
                        float transformAngle = 360 - globalRotation;
                        //Angle from the positive x-axis
                        float diffAngle = (transformAngle - angle + 360 + 180) % 360 - 180;
                        //Get the angle from AngleA
                        angle -= angleA;
                        if (angle < 0)
                            angle += 360;
                        //Ensure the distance of the point is less than the radius of the light and the angle is within the field of view
                        if (distance <= LightRadius && diffAngle <= (LightAngle / 2f) && diffAngle >= (-LightAngle / 2f))
                        {
                            int index = 0;
                            bool inserted = false;
                            //Insert the point ensuring angles remain sorted in increasing order
                            foreach (float tempAngle in angles)
                            {
                                if (angle <= tempAngle)
                                {
                                    angles.Insert(index, angle);
                                    raycastPoints.Insert(index, point);
                                    inserted = true;
                                    break;
                                }
                                index++;
                            }
                            if (!inserted)
                            {
                                angles.Add(angle);
                                raycastPoints.Add(point);
                            }
                        }
                    }
                }
            }

            //Get all the corner terrain points for raycasting
            int numRays = Mathf.CeilToInt(LightAngle * Resolution) + 1;
            float angleStep = LightAngle / numRays;
            Vector2 direction;
            //Shoot rays all around the lights field of view (FOV) and add the end point of the ray if it does not collide with any obstacles
            for (int i = 0; i < numRays; i++)
            {
                float angle = (360 - globalRotation) - LightAngle / 2f + angleStep * i;
                direction = AngleToDirection(angle, true);
                RaycastHit2D hit2D = Physics2D.Raycast(position, direction, LightRadius, ObstacleMask);
                if(hit2D.collider == null)
                {
                    Vector2 point = position + direction * LightRadius;
                    angle -= angleA;
                    if (angle < 0)
                        angle += 360;
                    int index = 0;
                    bool inserted = false;
                    foreach (float tempAngle in angles)
                    {
                        if (angle <= tempAngle)
                        {
                            angles.Insert(index, angle);
                            raycastPoints.Insert(index, point);
                            inserted = true;
                            break;
                        }
                        index++;
                    }
                    if (!inserted)
                    {
                        angles.Add(angle);
                        raycastPoints.Add(point);
                    }
                }
            }

            //Shoot a ray to the first point of the lights FOV if the Light Angle is not a complete 360 degrees
            List<float> distances = new List<float>();
            List<Vector2> directions = new List<Vector2>();
            RaycastHit2D hit;
            if (LightAngle != 360)
            {
                direction = AngleToDirection((360 - globalRotation) - LightAngle / 2f, true);
                hit = Physics2D.Raycast(position, direction, LightRadius, ObstacleMask);
                if (hit.collider != null)
                {
                    Debug.DrawRay(transform.position, direction * hit.distance, Color.green);
                    distances.Add(hit.distance);
                    directions.Add(direction);
                }
                else
                {
                    Debug.DrawRay(transform.position, direction * LightRadius, Color.red);
                    distances.Add(LightRadius);
                    directions.Add(direction);
                }
            }

            //Loop through all the Raycast Points and shoot rays immediately to the sides of each point
            foreach (Vector2 point in raycastPoints)
            {
                direction = (point - position).normalized;
                float angle = Mathf.Atan2(direction.x, direction.y) * Mathf.Rad2Deg;
                if (angle < 0)
                    angle += 360;

                Vector3 dirA = AngleToDirection(angle - RaycastOffset, true);
                RaycastHit2D hitA = Physics2D.Raycast(position, dirA, LightRadius, ObstacleMask);

                Vector3 dirB = AngleToDirection(angle + RaycastOffset, true);
                RaycastHit2D hitB = Physics2D.Raycast(position, dirB, LightRadius, ObstacleMask);

                //Check if either ray hits an obstacle that is not the Raycast Point
                if ((hitA.collider != null && Mathf.Abs(hitA.point.x - point.x) < RaycastHitThreshold && Mathf.Abs(hitA.point.y - point.y) < RaycastHitThreshold) || (hitB.collider != null) && Mathf.Abs(hitB.point.x - point.x) < 0.1f && Mathf.Abs(hitB.point.y - point.y) < 0.1f)
                {
                    //Both colliders hit an obstacle
                    if(hitA.collider != null && hitB.collider != null)
                    {
                        //If the distance between the two hit points is minimal just add hitA to the lists, else add them both
                        if(Mathf.Abs(hitA.distance - hitB.distance) < 0.1f)
                        {
                            distances.Add(hitA.distance);
                            directions.Add(dirA);
                            Debug.DrawRay(transform.position, dirA * hitA.distance, Color.blue);
                        } else
                        {
                            distances.Add(hitA.distance);
                            directions.Add(dirA);
                            Debug.DrawRay(transform.position, dirA * hitA.distance, Color.blue);

                            distances.Add(hitB.distance);
                            directions.Add(dirB);
                            Debug.DrawRay(transform.position, dirB * hitB.distance, Color.red);
                        }
                    //Only collider A hit an obstacle
                    } else if (hitA.collider != null)
                    {
                        //Add hitA to the lists
                        distances.Add(hitA.distance);
                        directions.Add(dirA);
                        Debug.DrawRay(transform.position, dirA * hitA.distance, Color.blue);

                        //Add the direction to hitB but use the lightRadius for the distance
                        distances.Add(LightRadius);
                        directions.Add(dirB);
                        Debug.DrawRay(transform.position, dirB * LightRadius, Color.red);
                    }
                    else if (hitB.collider != null)
                    {
                        distances.Add(LightRadius);
                        directions.Add(dirA);
                        Debug.DrawRay(transform.position, dirA * LightRadius, Color.blue);

                        distances.Add(hitB.distance);
                        directions.Add(dirB);
                        Debug.DrawRay(transform.position, dirB * hitB.distance, Color.red);
                    }

                }
                //No obstacles were hit
                else if (hitA.collider == null && hitB.collider == null)
                {
                    distances.Add(LightRadius);
                    directions.Add(dirA);
                    Debug.DrawRay(transform.position, dirA * LightRadius, Color.blue);
                }
            }
            //Shoot a ray to the last point of the lights FOV if the Light Angle is not a complete 360 degrees
            if (LightAngle != 360)
            {
                direction = AngleToDirection((360 - globalRotation) + LightAngle / 2f, true);
                hit = Physics2D.Raycast(position, direction, LightRadius, ObstacleMask);
                if (hit.collider != null)
                {
                    Debug.DrawRay(transform.position, direction * hit.distance, Color.green);
                    distances.Add(hit.distance);
                    directions.Add(direction);
                }
                else
                {
                    Debug.DrawRay(transform.position, direction * LightRadius, Color.red);
                    distances.Add(LightRadius);
                    directions.Add(direction);
                }
            }

            //Set the light points
            lightPoints.Clear();
            for (int i = 0; i < distances.Count; i++)
            {
                Vector2 point = transform.InverseTransformPoint(position + directions[i] * distances[i]);
                point += point.normalized * EdgeLightBleed;
                lightPoints.Add(point);
            }
        }

        /// <summary>
        /// Add the light points to the mesh
        /// </summary>
        protected override void CreateMesh()
        {
            vertices.Add(Vector3.zero);
            uvs.Add(new Vector2(0.5f, 0.5f));
            colors32.Add(LightColor);
            for (int i = 0; i < lightPoints.Count; i++)
            {
                vertices.Add(lightPoints[i]);

                triangles.Add(0);
                triangles.Add(i + 1);
                triangles.Add(i + 2);

                uvs.Add(new Vector2(lightPoints[i].x / (2 * LightRadius) + 0.5f, lightPoints[i].y / (2 * LightRadius) + 0.5f));
                colors32.Add(LightColor);
            }
            if (LightAngle == 360)
            {
                vertices.Add(lightPoints[0]);
                uvs.Add(uvs[1]);
                colors32.Add(LightColor);
            } else
            {
                vertices.Add(Vector3.zero);
                uvs.Add(new Vector2(0.5f, 0.5f));
                colors32.Add(LightColor);
            }

            UpdateMesh();
        }

    }
}
