using System.Collections.Generic;
using UnityEngine;

// Copyright (C) 2018 Matthew K Wilson

namespace TerrainEngine2D.Lighting
{
    /// <summary>
    /// Light generated by flood filling
    /// </summary>
    public class FloodLight : MeshLight
    {
        [Header("Floodfill")]
        /// <summary>
        /// The amount of blocks the light can pass through
        /// </summary>
        [Tooltip("Amount of blocks the light can pass through")]
        public int BlockLightTransfer = 3;
        private byte lightLayer;

        protected override void Start()
        {
            lightLayer = World.Instance.LightLayer;
            base.Start();
        }

        /// <summary>
        /// Calculate the light points
        /// </summary>
        protected override void CalculateLighting()
        {
            int x = Mathf.FloorToInt(transform.position.x);
            int y = Mathf.FloorToInt(transform.position.y);
            int cornerLightRadius = Mathf.RoundToInt(LightRadius * 0.7f);

            //Top
            int tempX = x;
            int tempY = y + 1;
            int lightTransferCount = 0;
            int blockCounter = 0;
            while(blockCounter < LightRadius)
            {
                if (world.GetBlockLayer(lightLayer).GetBlockType(tempX, tempY) != BlockLayer.AIR_BLOCK)
                {
                    lightTransferCount++;
                    if (lightTransferCount > BlockLightTransfer)
                        break;
                }
                else
                    lightTransferCount = 0;

                tempY++;
                blockCounter++;
            }
            lightPoints.Add(new Vector2(0, tempY - y));
            //Top-Right
            tempX = x + 1;
            tempY = y + 1;
            lightTransferCount = 0;
            blockCounter = 0;
            while (blockCounter < cornerLightRadius)
            {
                if (world.GetBlockLayer(lightLayer).GetBlockType(tempX, tempY) != BlockLayer.AIR_BLOCK)
                {
                    lightTransferCount++;
                    if (lightTransferCount > BlockLightTransfer)
                        break;
                }
                else
                    lightTransferCount = 0;

                tempY++;
                tempX++;
                blockCounter++;
            }
            lightPoints.Add(new Vector2(tempX - x, tempY - y));
            //Right
            tempX = x + 1;
            tempY = y;
            lightTransferCount = 0;
            blockCounter = 0;
            while (blockCounter < LightRadius)
            {
                if (world.GetBlockLayer(lightLayer).GetBlockType(tempX, tempY) != BlockLayer.AIR_BLOCK)
                {
                    lightTransferCount++;
                    if (lightTransferCount > BlockLightTransfer)
                        break;
                }
                else
                    lightTransferCount = 0;

                tempX++;
                blockCounter++;
            }
            lightPoints.Add(new Vector2(tempX - x, 0));
            //Bottom-Right
            tempX = x + 1;
            tempY = y - 1;
            lightTransferCount = 0;
            blockCounter = 0;
            while (blockCounter < cornerLightRadius)
            {
                if (world.GetBlockLayer(lightLayer).GetBlockType(tempX, tempY) != BlockLayer.AIR_BLOCK)
                {
                    lightTransferCount++;
                    if (lightTransferCount > BlockLightTransfer)
                        break;
                }
                else
                    lightTransferCount = 0;

                tempY--;
                tempX++;
                blockCounter++;
            }
            lightPoints.Add(new Vector2(tempX - x - 1, tempY - y + 1));
            //Bottom
            tempX = x;
            tempY = y - 1;
            lightTransferCount = 0;
            blockCounter = 0;
            while (blockCounter < LightRadius)
            {
                if (world.GetBlockLayer(lightLayer).GetBlockType(tempX, tempY) != BlockLayer.AIR_BLOCK)
                {
                    lightTransferCount++;
                    if (lightTransferCount > BlockLightTransfer)
                        break;
                }
                else
                    lightTransferCount = 0;

                tempY--;
                blockCounter++;
            }
            lightPoints.Add(new Vector2(0, tempY - y + 1));
            //Bottom-Left
            tempX = x - 1;
            tempY = y - 1;
            lightTransferCount = 0;
            blockCounter = 0;
            while (blockCounter < cornerLightRadius)
            {
                if (world.GetBlockLayer(lightLayer).GetBlockType(tempX, tempY) != BlockLayer.AIR_BLOCK)
                {
                    lightTransferCount++;
                    if (lightTransferCount > BlockLightTransfer)
                        break;
                }
                else
                    lightTransferCount = 0;

                tempY--;
                tempX--;
                blockCounter++;
            }
            lightPoints.Add(new Vector2(tempX - x + 1, tempY - y + 1));
            //Left
            tempX = x - 1;
            tempY = y;
            lightTransferCount = 0;
            blockCounter = 0;
            while (blockCounter < LightRadius)
            {
                if (world.GetBlockLayer(lightLayer).GetBlockType(tempX, tempY) != BlockLayer.AIR_BLOCK)
                {
                    lightTransferCount++;
                    if (lightTransferCount > BlockLightTransfer)
                        break;
                }
                else
                    lightTransferCount = 0;

                tempX--;
                blockCounter++;
            }
            lightPoints.Add(new Vector2(tempX - x + 1, 0));
            //Top-Left
            tempX = x - 1;
            tempY = y + 1;
            lightTransferCount = 0;
            blockCounter = 0;
            while (blockCounter < cornerLightRadius)
            {
                if (world.GetBlockLayer(lightLayer).GetBlockType(tempX, tempY) != BlockLayer.AIR_BLOCK)
                {
                    lightTransferCount++;
                    if (lightTransferCount > BlockLightTransfer)
                        break;
                }
                else
                    lightTransferCount = 0;

                tempY++;
                tempX--;
                blockCounter++;
            }
            lightPoints.Add(new Vector2(tempX - x, tempY - y));
        }

        /// <summary>
        /// Smooth the light mesh points by point averaging
        /// </summary>
        protected override void SmoothPoints()
        {
            List<Vector2> newPoints = new List<Vector2>();
            for (int i = 0; i < SmoothingIterations; i++)
            {
                float smoothingFactor = 1 + (1 / Mathf.Pow(10, i + 1));
                for (int j = 0; j < lightPoints.Count; j++)
                {
                    Vector2 curr, next;
                    curr = lightPoints[j];
                    if (j == (lightPoints.Count - 1))
                        next = lightPoints[0];
                    else
                        next = lightPoints[j + 1];

                    newPoints.Add((curr + next) / 2 * smoothingFactor);
                }

                for (int j = 0; j < newPoints.Count; j++)
                {
                    lightPoints.Insert(2 * j + 1, newPoints[j]);
                }

                newPoints.Clear();
            }
        }

        /// <summary>
        /// Add the light points to the mesh
        /// </summary>
        protected override void CreateMesh()
        {
            vertices.Add(Vector3.zero);
            uvs.Add(new Vector2(0.5f, 0.5f));
            colors32.Add(LightColor);
            for (int i = 0; i < lightPoints.Count; i++)
            {
                vertices.Add(lightPoints[i]);

                triangles.Add(0);
                triangles.Add(i + 1);
                triangles.Add(i + 2);

                uvs.Add(new Vector2(lightPoints[i].x / (2 * LightRadius) + 0.5f, lightPoints[i].y / (2 * LightRadius) + 0.5f));
                colors32.Add(LightColor);
            }
            vertices.Add(lightPoints[0]);
            uvs.Add(uvs[1]);
            colors32.Add(LightColor);

            UpdateMesh();
        }

    }
}
